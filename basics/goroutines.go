// Горутины (goroutines) представляют параллельные операции, которые могут выполняться независимо от функции, в которой они запущены.
// Это есть реализация многопоточности
func f() {

}

go f()

// Каналы
// Каналы (channels) представляют инструменты коммуникации между горутинами.
	
var intCh chan int	// После слова chan указывается тип данных, которые будут передаться с помощью канала
intCh <- 5 			// Передача данных в канал
val := <- intCh 	// Передача данных из канала
// Как правило, отправителем данных является одна горутина, а получателем - другая горутина.
// При простом определении переменной канала она имеет значение nil
// Для инициализации применяется функция make()

// Для создания небуферизированного канала вызывается функция make() без указания емкости канала.
var intCh chan int = make(chan int) // канал для данных типа int
strCh := make(chan string)  // канал для данных типа string
// Горутина-отправитель может отправлять данные только в пустой канал. 
// Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены.

// Буферизированные каналы также создаются с помощью функции make(), 
// только в качестве второго аргумента в функцию передается емкость канала. 
intCh := make(chan int, 3) 
intCh <- 10
intCh <- 3
intCh <- 24
fmt.Println(<-intCh)     	// 10
fmt.Println(<-intCh)     	// 3
fmt.Println(<-intCh)     	//24
cap(intCh)					// 3 - емкость
len(intCh)					// 3 - кол-во элементов

var inCh chan<- int 		// Канал только для отправки данных
var outCh <-chan int		// Канал только для получения данных

// Канал может быть возвращаемым значение функции, но операции чтения-записи в канал следует вынести в отдельную горутину
func createChan(n int) chan int{
    ch := make(chan int)    // создаем канал
    go func(){
        ch <- n      // отправляем данные в канал
    }()             // запускаем горутину
    return ch   // возвращаем канал
}

// Канал можно закрыть с помощью встроенной функции close
intCh := make(chan int, 3) 
intCh <- 10
intCh <- 3
close(intCh)
// После закрытия канала можно из него получать данные, но нельзя отправлять
val, opened := <-intCh	// Второе значение - это логическое значение открыт ли канал

// Мьютексы
// Для упрощения синхронизации между горутинами в Go имеется пакет sync, который предоставляет ряд возможностей, в частности мьютексы.
// Они позволяют разграничить доступ к некоторым общим ресурсам, гарантируя, 
// что только одна горутина имеет к ним доступ в определенный момент времени. 
import "sync"
var mutex sync.Mutex        // определяем мьютекс
mutex.Lock()    // блокируем доступ к переменной counter
mutex.Unlock()  // деблокируем доступ
// при вызове mutex ресурс блокируется и только одно горутина имеет доступ к этому ресурсу, после Unlock горутина освобождает доступ и далее

// WaitGroup
// sync.WaitGroup позволяет определить группу горутин, которые должны выполняться вместе как одна группа.
var wg sync.WaitGroup 	// Инициализация
wg.Add(2)       		// в группе две горутины
work := func(id int) { 
	defer wg.Done()		// После завершения горутины сигнализировать, что элемент группы завершил свое выполнение
	fmt.Printf("Горутина %d начала выполнение \n", id) 
	time.Sleep(2 * time.Second)
	fmt.Printf("Горутина %d завершила выполнение \n", id) 
} 

// вызываем горутины
go work(1) 
go work(2) 

wg.Wait()        // ожидаем завершения обоих горутин
fmt.Println("Горутины завершили выполнение") 